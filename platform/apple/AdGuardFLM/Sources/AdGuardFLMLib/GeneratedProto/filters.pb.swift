// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: filters.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

public struct FilterListManager_FilterTag {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Filter tag id.
  public var id: Int32 = 0

  /// Filter keyword (purpose, lang, platform, etc.)
  public var keyword: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct FilterListManager_FilterGroup {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Group id
  public var id: Int32 = 0

  /// Group name
  public var name: String = String()

  /// Display number for ordering
  public var displayNumber: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct FilterListManager_FilterListRules {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Associated filter id.
  public var filterID: Int64 = 0

  /// List of all rules in the filter list.
  public var rules: [String] = []

  /// List of only disabled rules.
  public var disabledRules: [String] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct FilterListManager_FilterListRulesRaw {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Associated filter id.
  public var filterID: Int64 = 0

  /// List of all rules in the filter list as string.
  public var rules: String = String()

  /// List of only disabled rules as string.
  public var disabledRules: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct FilterListManager_DisabledRulesRaw {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Associated filter id.
  public var filterID: Int64 = 0

  /// List of only disabled rules as string.
  public var text: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct FilterListManager_FilterListMetadata {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Title from the `! Title:` metadata field.
  public var title: String = String()

  /// Description from the `! Description:` metadata field.
  public var description_p: String = String()

  /// Time updated from the `! TimeUpdated:` metadata field.
  public var timeUpdated: String = String()

  /// Version from the `! Version:` metadata field.
  public var version: String = String()

  /// Homepage from the `! Homepage:` metadata field.
  public var homepage: String = String()

  /// License from the `! License:` metadata field.
  public var license: String = String()

  /// Checksum from the `! Checksum:` metadata field.
  public var checksum: String = String()

  /// URL or local path where the filter content was downloaded from.
  public var url: String = String()

  /// Rules count in this filter list.
  public var rulesCount: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct FilterListManager_StoredFilterMetadata {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Filter list unique ID
  public var id: Int64 {
    get {return _storage._id}
    set {_uniqueStorage()._id = newValue}
  }

  /// Group ID this filter list belongs to
  public var groupID: Int32 {
    get {return _storage._groupID}
    set {_uniqueStorage()._groupID = newValue}
  }

  /// Timestamp (seconds from epoch) when this filter was updated on the server
  public var timeUpdated: Int64 {
    get {return _storage._timeUpdated}
    set {_uniqueStorage()._timeUpdated = newValue}
  }

  /// Timestamp (seconds from epoch) when this filter list's content was last downloaded
  public var lastDownloadTime: Int64 {
    get {return _storage._lastDownloadTime}
    set {_uniqueStorage()._lastDownloadTime = newValue}
  }

  /// Title either from the list metadata or parsed from the content
  public var title: String {
    get {return _storage._title}
    set {_uniqueStorage()._title = newValue}
  }

  /// Description either from the list metadata or parsed from the content
  public var description_p: String {
    get {return _storage._description_p}
    set {_uniqueStorage()._description_p = newValue}
  }

  /// Version either from the list metadata or parsed from the content
  public var version: String {
    get {return _storage._version}
    set {_uniqueStorage()._version = newValue}
  }

  /// Filter list display number
  public var displayNumber: Int32 {
    get {return _storage._displayNumber}
    set {_uniqueStorage()._displayNumber = newValue}
  }

  /// Filter list download URL
  public var downloadURL: String {
    get {return _storage._downloadURL}
    set {_uniqueStorage()._downloadURL = newValue}
  }

  /// Filter list subscription source URL
  public var subscriptionURL: String {
    get {return _storage._subscriptionURL}
    set {_uniqueStorage()._subscriptionURL = newValue}
  }

  /// An array of tags of this filter list
  public var tags: [FilterListManager_FilterTag] {
    get {return _storage._tags}
    set {_uniqueStorage()._tags = newValue}
  }

  /// Number of seconds until the filter list is considered outdated
  public var expires: Int32 {
    get {return _storage._expires}
    set {_uniqueStorage()._expires = newValue}
  }

  /// Indicates if the filter list is trusted or not
  public var isTrusted: Bool {
    get {return _storage._isTrusted}
    set {_uniqueStorage()._isTrusted = newValue}
  }

  /// Indicates if the filter list is custom or comes from the registry
  public var isCustom: Bool {
    get {return _storage._isCustom}
    set {_uniqueStorage()._isCustom = newValue}
  }

  /// Indicates whether the filter list is enabled
  public var isEnabled: Bool {
    get {return _storage._isEnabled}
    set {_uniqueStorage()._isEnabled = newValue}
  }

  /// Indicates if the filter list is installed
  public var isInstalled: Bool {
    get {return _storage._isInstalled}
    set {_uniqueStorage()._isInstalled = newValue}
  }

  /// List homepage URL
  public var homepage: String {
    get {return _storage._homepage}
    set {_uniqueStorage()._homepage = newValue}
  }

  /// List license URL
  public var license: String {
    get {return _storage._license}
    set {_uniqueStorage()._license = newValue}
  }

  /// Filter checksum
  public var checksum: String {
    get {return _storage._checksum}
    set {_uniqueStorage()._checksum = newValue}
  }

  /// List of languages the filter supports
  public var languages: [String] {
    get {return _storage._languages}
    set {_uniqueStorage()._languages = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct FilterListManager_FullFilterList {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Filter list unique ID
  public var id: Int64 {
    get {return _storage._id}
    set {_uniqueStorage()._id = newValue}
  }

  /// Group ID this filter list belongs to
  public var groupID: Int32 {
    get {return _storage._groupID}
    set {_uniqueStorage()._groupID = newValue}
  }

  /// Timestamp (seconds from epoch) when this filter was updated on the server
  public var timeUpdated: Int64 {
    get {return _storage._timeUpdated}
    set {_uniqueStorage()._timeUpdated = newValue}
  }

  /// Timestamp (seconds from epoch) when this filter list's content was last downloaded
  public var lastDownloadTime: Int64 {
    get {return _storage._lastDownloadTime}
    set {_uniqueStorage()._lastDownloadTime = newValue}
  }

  /// Title either from the list metadata or parsed from the content
  public var title: String {
    get {return _storage._title}
    set {_uniqueStorage()._title = newValue}
  }

  /// Description either from the list metadata or parsed from the content
  public var description_p: String {
    get {return _storage._description_p}
    set {_uniqueStorage()._description_p = newValue}
  }

  /// Version either from the list metadata or parsed from the content
  public var version: String {
    get {return _storage._version}
    set {_uniqueStorage()._version = newValue}
  }

  /// Filter list display number
  public var displayNumber: Int32 {
    get {return _storage._displayNumber}
    set {_uniqueStorage()._displayNumber = newValue}
  }

  /// Filter list download URL
  public var downloadURL: String {
    get {return _storage._downloadURL}
    set {_uniqueStorage()._downloadURL = newValue}
  }

  /// Filter list subscription source URL
  public var subscriptionURL: String {
    get {return _storage._subscriptionURL}
    set {_uniqueStorage()._subscriptionURL = newValue}
  }

  /// An array of tags of this filter list
  public var tags: [FilterListManager_FilterTag] {
    get {return _storage._tags}
    set {_uniqueStorage()._tags = newValue}
  }

  /// Number of seconds until the filter list is considered outdated
  public var expires: Int32 {
    get {return _storage._expires}
    set {_uniqueStorage()._expires = newValue}
  }

  /// Indicates if the filter list is trusted or not
  public var isTrusted: Bool {
    get {return _storage._isTrusted}
    set {_uniqueStorage()._isTrusted = newValue}
  }

  /// Indicates if the filter list is custom or comes from the registry
  public var isCustom: Bool {
    get {return _storage._isCustom}
    set {_uniqueStorage()._isCustom = newValue}
  }

  /// Indicates whether the filter list is enabled
  public var isEnabled: Bool {
    get {return _storage._isEnabled}
    set {_uniqueStorage()._isEnabled = newValue}
  }

  /// Indicates if the filter list is installed
  public var isInstalled: Bool {
    get {return _storage._isInstalled}
    set {_uniqueStorage()._isInstalled = newValue}
  }

  /// List homepage URL
  public var homepage: String {
    get {return _storage._homepage}
    set {_uniqueStorage()._homepage = newValue}
  }

  /// List license URL
  public var license: String {
    get {return _storage._license}
    set {_uniqueStorage()._license = newValue}
  }

  /// Filter checksum
  public var checksum: String {
    get {return _storage._checksum}
    set {_uniqueStorage()._checksum = newValue}
  }

  /// List of languages the filter supports
  public var languages: [String] {
    get {return _storage._languages}
    set {_uniqueStorage()._languages = newValue}
  }

  /// Optional container for rules
  public var rules: FilterListManager_FilterListRules {
    get {return _storage._rules ?? FilterListManager_FilterListRules()}
    set {_uniqueStorage()._rules = newValue}
  }
  /// Returns true if `rules` has been explicitly set.
  public var hasRules: Bool {return _storage._rules != nil}
  /// Clears the value of `rules`. Subsequent reads from it will return its default value.
  public mutating func clearRules() {_uniqueStorage()._rules = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

#if swift(>=5.5) && canImport(_Concurrency)
extension FilterListManager_FilterTag: @unchecked Sendable {}
extension FilterListManager_FilterGroup: @unchecked Sendable {}
extension FilterListManager_FilterListRules: @unchecked Sendable {}
extension FilterListManager_FilterListRulesRaw: @unchecked Sendable {}
extension FilterListManager_DisabledRulesRaw: @unchecked Sendable {}
extension FilterListManager_FilterListMetadata: @unchecked Sendable {}
extension FilterListManager_StoredFilterMetadata: @unchecked Sendable {}
extension FilterListManager_FullFilterList: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "filter_list_manager"

extension FilterListManager_FilterTag: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".FilterTag"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "keyword"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.id) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.keyword) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.id != 0 {
      try visitor.visitSingularInt32Field(value: self.id, fieldNumber: 1)
    }
    if !self.keyword.isEmpty {
      try visitor.visitSingularStringField(value: self.keyword, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: FilterListManager_FilterTag, rhs: FilterListManager_FilterTag) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.keyword != rhs.keyword {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension FilterListManager_FilterGroup: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".FilterGroup"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "name"),
    3: .standard(proto: "display_number"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.id) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.displayNumber) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.id != 0 {
      try visitor.visitSingularInt32Field(value: self.id, fieldNumber: 1)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 2)
    }
    if self.displayNumber != 0 {
      try visitor.visitSingularInt32Field(value: self.displayNumber, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: FilterListManager_FilterGroup, rhs: FilterListManager_FilterGroup) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.name != rhs.name {return false}
    if lhs.displayNumber != rhs.displayNumber {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension FilterListManager_FilterListRules: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".FilterListRules"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "filter_id"),
    2: .same(proto: "rules"),
    3: .standard(proto: "disabled_rules"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.filterID) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.rules) }()
      case 3: try { try decoder.decodeRepeatedStringField(value: &self.disabledRules) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.filterID != 0 {
      try visitor.visitSingularInt64Field(value: self.filterID, fieldNumber: 1)
    }
    if !self.rules.isEmpty {
      try visitor.visitRepeatedStringField(value: self.rules, fieldNumber: 2)
    }
    if !self.disabledRules.isEmpty {
      try visitor.visitRepeatedStringField(value: self.disabledRules, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: FilterListManager_FilterListRules, rhs: FilterListManager_FilterListRules) -> Bool {
    if lhs.filterID != rhs.filterID {return false}
    if lhs.rules != rhs.rules {return false}
    if lhs.disabledRules != rhs.disabledRules {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension FilterListManager_FilterListRulesRaw: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".FilterListRulesRaw"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "filter_id"),
    2: .same(proto: "rules"),
    3: .standard(proto: "disabled_rules"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.filterID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.rules) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.disabledRules) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.filterID != 0 {
      try visitor.visitSingularInt64Field(value: self.filterID, fieldNumber: 1)
    }
    if !self.rules.isEmpty {
      try visitor.visitSingularStringField(value: self.rules, fieldNumber: 2)
    }
    if !self.disabledRules.isEmpty {
      try visitor.visitSingularStringField(value: self.disabledRules, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: FilterListManager_FilterListRulesRaw, rhs: FilterListManager_FilterListRulesRaw) -> Bool {
    if lhs.filterID != rhs.filterID {return false}
    if lhs.rules != rhs.rules {return false}
    if lhs.disabledRules != rhs.disabledRules {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension FilterListManager_DisabledRulesRaw: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DisabledRulesRaw"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "filter_id"),
    2: .same(proto: "text"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.filterID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.text) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.filterID != 0 {
      try visitor.visitSingularInt64Field(value: self.filterID, fieldNumber: 1)
    }
    if !self.text.isEmpty {
      try visitor.visitSingularStringField(value: self.text, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: FilterListManager_DisabledRulesRaw, rhs: FilterListManager_DisabledRulesRaw) -> Bool {
    if lhs.filterID != rhs.filterID {return false}
    if lhs.text != rhs.text {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension FilterListManager_FilterListMetadata: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".FilterListMetadata"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "title"),
    2: .same(proto: "description"),
    3: .standard(proto: "time_updated"),
    4: .same(proto: "version"),
    5: .same(proto: "homepage"),
    6: .same(proto: "license"),
    7: .same(proto: "checksum"),
    8: .same(proto: "url"),
    9: .standard(proto: "rules_count"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.title) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.timeUpdated) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.version) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.homepage) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.license) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.checksum) }()
      case 8: try { try decoder.decodeSingularStringField(value: &self.url) }()
      case 9: try { try decoder.decodeSingularInt32Field(value: &self.rulesCount) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.title.isEmpty {
      try visitor.visitSingularStringField(value: self.title, fieldNumber: 1)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 2)
    }
    if !self.timeUpdated.isEmpty {
      try visitor.visitSingularStringField(value: self.timeUpdated, fieldNumber: 3)
    }
    if !self.version.isEmpty {
      try visitor.visitSingularStringField(value: self.version, fieldNumber: 4)
    }
    if !self.homepage.isEmpty {
      try visitor.visitSingularStringField(value: self.homepage, fieldNumber: 5)
    }
    if !self.license.isEmpty {
      try visitor.visitSingularStringField(value: self.license, fieldNumber: 6)
    }
    if !self.checksum.isEmpty {
      try visitor.visitSingularStringField(value: self.checksum, fieldNumber: 7)
    }
    if !self.url.isEmpty {
      try visitor.visitSingularStringField(value: self.url, fieldNumber: 8)
    }
    if self.rulesCount != 0 {
      try visitor.visitSingularInt32Field(value: self.rulesCount, fieldNumber: 9)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: FilterListManager_FilterListMetadata, rhs: FilterListManager_FilterListMetadata) -> Bool {
    if lhs.title != rhs.title {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.timeUpdated != rhs.timeUpdated {return false}
    if lhs.version != rhs.version {return false}
    if lhs.homepage != rhs.homepage {return false}
    if lhs.license != rhs.license {return false}
    if lhs.checksum != rhs.checksum {return false}
    if lhs.url != rhs.url {return false}
    if lhs.rulesCount != rhs.rulesCount {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension FilterListManager_StoredFilterMetadata: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".StoredFilterMetadata"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .standard(proto: "group_id"),
    3: .standard(proto: "time_updated"),
    4: .standard(proto: "last_download_time"),
    5: .same(proto: "title"),
    6: .same(proto: "description"),
    7: .same(proto: "version"),
    8: .standard(proto: "display_number"),
    9: .standard(proto: "download_url"),
    10: .standard(proto: "subscription_url"),
    11: .same(proto: "tags"),
    12: .same(proto: "expires"),
    13: .standard(proto: "is_trusted"),
    14: .standard(proto: "is_custom"),
    15: .standard(proto: "is_enabled"),
    16: .standard(proto: "is_installed"),
    17: .same(proto: "homepage"),
    18: .same(proto: "license"),
    19: .same(proto: "checksum"),
    20: .same(proto: "languages"),
  ]

  fileprivate class _StorageClass {
    var _id: Int64 = 0
    var _groupID: Int32 = 0
    var _timeUpdated: Int64 = 0
    var _lastDownloadTime: Int64 = 0
    var _title: String = String()
    var _description_p: String = String()
    var _version: String = String()
    var _displayNumber: Int32 = 0
    var _downloadURL: String = String()
    var _subscriptionURL: String = String()
    var _tags: [FilterListManager_FilterTag] = []
    var _expires: Int32 = 0
    var _isTrusted: Bool = false
    var _isCustom: Bool = false
    var _isEnabled: Bool = false
    var _isInstalled: Bool = false
    var _homepage: String = String()
    var _license: String = String()
    var _checksum: String = String()
    var _languages: [String] = []

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _id = source._id
      _groupID = source._groupID
      _timeUpdated = source._timeUpdated
      _lastDownloadTime = source._lastDownloadTime
      _title = source._title
      _description_p = source._description_p
      _version = source._version
      _displayNumber = source._displayNumber
      _downloadURL = source._downloadURL
      _subscriptionURL = source._subscriptionURL
      _tags = source._tags
      _expires = source._expires
      _isTrusted = source._isTrusted
      _isCustom = source._isCustom
      _isEnabled = source._isEnabled
      _isInstalled = source._isInstalled
      _homepage = source._homepage
      _license = source._license
      _checksum = source._checksum
      _languages = source._languages
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularInt64Field(value: &_storage._id) }()
        case 2: try { try decoder.decodeSingularInt32Field(value: &_storage._groupID) }()
        case 3: try { try decoder.decodeSingularInt64Field(value: &_storage._timeUpdated) }()
        case 4: try { try decoder.decodeSingularInt64Field(value: &_storage._lastDownloadTime) }()
        case 5: try { try decoder.decodeSingularStringField(value: &_storage._title) }()
        case 6: try { try decoder.decodeSingularStringField(value: &_storage._description_p) }()
        case 7: try { try decoder.decodeSingularStringField(value: &_storage._version) }()
        case 8: try { try decoder.decodeSingularInt32Field(value: &_storage._displayNumber) }()
        case 9: try { try decoder.decodeSingularStringField(value: &_storage._downloadURL) }()
        case 10: try { try decoder.decodeSingularStringField(value: &_storage._subscriptionURL) }()
        case 11: try { try decoder.decodeRepeatedMessageField(value: &_storage._tags) }()
        case 12: try { try decoder.decodeSingularInt32Field(value: &_storage._expires) }()
        case 13: try { try decoder.decodeSingularBoolField(value: &_storage._isTrusted) }()
        case 14: try { try decoder.decodeSingularBoolField(value: &_storage._isCustom) }()
        case 15: try { try decoder.decodeSingularBoolField(value: &_storage._isEnabled) }()
        case 16: try { try decoder.decodeSingularBoolField(value: &_storage._isInstalled) }()
        case 17: try { try decoder.decodeSingularStringField(value: &_storage._homepage) }()
        case 18: try { try decoder.decodeSingularStringField(value: &_storage._license) }()
        case 19: try { try decoder.decodeSingularStringField(value: &_storage._checksum) }()
        case 20: try { try decoder.decodeRepeatedStringField(value: &_storage._languages) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._id != 0 {
        try visitor.visitSingularInt64Field(value: _storage._id, fieldNumber: 1)
      }
      if _storage._groupID != 0 {
        try visitor.visitSingularInt32Field(value: _storage._groupID, fieldNumber: 2)
      }
      if _storage._timeUpdated != 0 {
        try visitor.visitSingularInt64Field(value: _storage._timeUpdated, fieldNumber: 3)
      }
      if _storage._lastDownloadTime != 0 {
        try visitor.visitSingularInt64Field(value: _storage._lastDownloadTime, fieldNumber: 4)
      }
      if !_storage._title.isEmpty {
        try visitor.visitSingularStringField(value: _storage._title, fieldNumber: 5)
      }
      if !_storage._description_p.isEmpty {
        try visitor.visitSingularStringField(value: _storage._description_p, fieldNumber: 6)
      }
      if !_storage._version.isEmpty {
        try visitor.visitSingularStringField(value: _storage._version, fieldNumber: 7)
      }
      if _storage._displayNumber != 0 {
        try visitor.visitSingularInt32Field(value: _storage._displayNumber, fieldNumber: 8)
      }
      if !_storage._downloadURL.isEmpty {
        try visitor.visitSingularStringField(value: _storage._downloadURL, fieldNumber: 9)
      }
      if !_storage._subscriptionURL.isEmpty {
        try visitor.visitSingularStringField(value: _storage._subscriptionURL, fieldNumber: 10)
      }
      if !_storage._tags.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._tags, fieldNumber: 11)
      }
      if _storage._expires != 0 {
        try visitor.visitSingularInt32Field(value: _storage._expires, fieldNumber: 12)
      }
      if _storage._isTrusted != false {
        try visitor.visitSingularBoolField(value: _storage._isTrusted, fieldNumber: 13)
      }
      if _storage._isCustom != false {
        try visitor.visitSingularBoolField(value: _storage._isCustom, fieldNumber: 14)
      }
      if _storage._isEnabled != false {
        try visitor.visitSingularBoolField(value: _storage._isEnabled, fieldNumber: 15)
      }
      if _storage._isInstalled != false {
        try visitor.visitSingularBoolField(value: _storage._isInstalled, fieldNumber: 16)
      }
      if !_storage._homepage.isEmpty {
        try visitor.visitSingularStringField(value: _storage._homepage, fieldNumber: 17)
      }
      if !_storage._license.isEmpty {
        try visitor.visitSingularStringField(value: _storage._license, fieldNumber: 18)
      }
      if !_storage._checksum.isEmpty {
        try visitor.visitSingularStringField(value: _storage._checksum, fieldNumber: 19)
      }
      if !_storage._languages.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._languages, fieldNumber: 20)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: FilterListManager_StoredFilterMetadata, rhs: FilterListManager_StoredFilterMetadata) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._id != rhs_storage._id {return false}
        if _storage._groupID != rhs_storage._groupID {return false}
        if _storage._timeUpdated != rhs_storage._timeUpdated {return false}
        if _storage._lastDownloadTime != rhs_storage._lastDownloadTime {return false}
        if _storage._title != rhs_storage._title {return false}
        if _storage._description_p != rhs_storage._description_p {return false}
        if _storage._version != rhs_storage._version {return false}
        if _storage._displayNumber != rhs_storage._displayNumber {return false}
        if _storage._downloadURL != rhs_storage._downloadURL {return false}
        if _storage._subscriptionURL != rhs_storage._subscriptionURL {return false}
        if _storage._tags != rhs_storage._tags {return false}
        if _storage._expires != rhs_storage._expires {return false}
        if _storage._isTrusted != rhs_storage._isTrusted {return false}
        if _storage._isCustom != rhs_storage._isCustom {return false}
        if _storage._isEnabled != rhs_storage._isEnabled {return false}
        if _storage._isInstalled != rhs_storage._isInstalled {return false}
        if _storage._homepage != rhs_storage._homepage {return false}
        if _storage._license != rhs_storage._license {return false}
        if _storage._checksum != rhs_storage._checksum {return false}
        if _storage._languages != rhs_storage._languages {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension FilterListManager_FullFilterList: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".FullFilterList"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .standard(proto: "group_id"),
    3: .standard(proto: "time_updated"),
    4: .standard(proto: "last_download_time"),
    5: .same(proto: "title"),
    6: .same(proto: "description"),
    7: .same(proto: "version"),
    8: .standard(proto: "display_number"),
    9: .standard(proto: "download_url"),
    10: .standard(proto: "subscription_url"),
    11: .same(proto: "tags"),
    12: .same(proto: "expires"),
    13: .standard(proto: "is_trusted"),
    14: .standard(proto: "is_custom"),
    15: .standard(proto: "is_enabled"),
    16: .standard(proto: "is_installed"),
    17: .same(proto: "homepage"),
    18: .same(proto: "license"),
    19: .same(proto: "checksum"),
    20: .same(proto: "languages"),
    21: .same(proto: "rules"),
  ]

  fileprivate class _StorageClass {
    var _id: Int64 = 0
    var _groupID: Int32 = 0
    var _timeUpdated: Int64 = 0
    var _lastDownloadTime: Int64 = 0
    var _title: String = String()
    var _description_p: String = String()
    var _version: String = String()
    var _displayNumber: Int32 = 0
    var _downloadURL: String = String()
    var _subscriptionURL: String = String()
    var _tags: [FilterListManager_FilterTag] = []
    var _expires: Int32 = 0
    var _isTrusted: Bool = false
    var _isCustom: Bool = false
    var _isEnabled: Bool = false
    var _isInstalled: Bool = false
    var _homepage: String = String()
    var _license: String = String()
    var _checksum: String = String()
    var _languages: [String] = []
    var _rules: FilterListManager_FilterListRules? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _id = source._id
      _groupID = source._groupID
      _timeUpdated = source._timeUpdated
      _lastDownloadTime = source._lastDownloadTime
      _title = source._title
      _description_p = source._description_p
      _version = source._version
      _displayNumber = source._displayNumber
      _downloadURL = source._downloadURL
      _subscriptionURL = source._subscriptionURL
      _tags = source._tags
      _expires = source._expires
      _isTrusted = source._isTrusted
      _isCustom = source._isCustom
      _isEnabled = source._isEnabled
      _isInstalled = source._isInstalled
      _homepage = source._homepage
      _license = source._license
      _checksum = source._checksum
      _languages = source._languages
      _rules = source._rules
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularInt64Field(value: &_storage._id) }()
        case 2: try { try decoder.decodeSingularInt32Field(value: &_storage._groupID) }()
        case 3: try { try decoder.decodeSingularInt64Field(value: &_storage._timeUpdated) }()
        case 4: try { try decoder.decodeSingularInt64Field(value: &_storage._lastDownloadTime) }()
        case 5: try { try decoder.decodeSingularStringField(value: &_storage._title) }()
        case 6: try { try decoder.decodeSingularStringField(value: &_storage._description_p) }()
        case 7: try { try decoder.decodeSingularStringField(value: &_storage._version) }()
        case 8: try { try decoder.decodeSingularInt32Field(value: &_storage._displayNumber) }()
        case 9: try { try decoder.decodeSingularStringField(value: &_storage._downloadURL) }()
        case 10: try { try decoder.decodeSingularStringField(value: &_storage._subscriptionURL) }()
        case 11: try { try decoder.decodeRepeatedMessageField(value: &_storage._tags) }()
        case 12: try { try decoder.decodeSingularInt32Field(value: &_storage._expires) }()
        case 13: try { try decoder.decodeSingularBoolField(value: &_storage._isTrusted) }()
        case 14: try { try decoder.decodeSingularBoolField(value: &_storage._isCustom) }()
        case 15: try { try decoder.decodeSingularBoolField(value: &_storage._isEnabled) }()
        case 16: try { try decoder.decodeSingularBoolField(value: &_storage._isInstalled) }()
        case 17: try { try decoder.decodeSingularStringField(value: &_storage._homepage) }()
        case 18: try { try decoder.decodeSingularStringField(value: &_storage._license) }()
        case 19: try { try decoder.decodeSingularStringField(value: &_storage._checksum) }()
        case 20: try { try decoder.decodeRepeatedStringField(value: &_storage._languages) }()
        case 21: try { try decoder.decodeSingularMessageField(value: &_storage._rules) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if _storage._id != 0 {
        try visitor.visitSingularInt64Field(value: _storage._id, fieldNumber: 1)
      }
      if _storage._groupID != 0 {
        try visitor.visitSingularInt32Field(value: _storage._groupID, fieldNumber: 2)
      }
      if _storage._timeUpdated != 0 {
        try visitor.visitSingularInt64Field(value: _storage._timeUpdated, fieldNumber: 3)
      }
      if _storage._lastDownloadTime != 0 {
        try visitor.visitSingularInt64Field(value: _storage._lastDownloadTime, fieldNumber: 4)
      }
      if !_storage._title.isEmpty {
        try visitor.visitSingularStringField(value: _storage._title, fieldNumber: 5)
      }
      if !_storage._description_p.isEmpty {
        try visitor.visitSingularStringField(value: _storage._description_p, fieldNumber: 6)
      }
      if !_storage._version.isEmpty {
        try visitor.visitSingularStringField(value: _storage._version, fieldNumber: 7)
      }
      if _storage._displayNumber != 0 {
        try visitor.visitSingularInt32Field(value: _storage._displayNumber, fieldNumber: 8)
      }
      if !_storage._downloadURL.isEmpty {
        try visitor.visitSingularStringField(value: _storage._downloadURL, fieldNumber: 9)
      }
      if !_storage._subscriptionURL.isEmpty {
        try visitor.visitSingularStringField(value: _storage._subscriptionURL, fieldNumber: 10)
      }
      if !_storage._tags.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._tags, fieldNumber: 11)
      }
      if _storage._expires != 0 {
        try visitor.visitSingularInt32Field(value: _storage._expires, fieldNumber: 12)
      }
      if _storage._isTrusted != false {
        try visitor.visitSingularBoolField(value: _storage._isTrusted, fieldNumber: 13)
      }
      if _storage._isCustom != false {
        try visitor.visitSingularBoolField(value: _storage._isCustom, fieldNumber: 14)
      }
      if _storage._isEnabled != false {
        try visitor.visitSingularBoolField(value: _storage._isEnabled, fieldNumber: 15)
      }
      if _storage._isInstalled != false {
        try visitor.visitSingularBoolField(value: _storage._isInstalled, fieldNumber: 16)
      }
      if !_storage._homepage.isEmpty {
        try visitor.visitSingularStringField(value: _storage._homepage, fieldNumber: 17)
      }
      if !_storage._license.isEmpty {
        try visitor.visitSingularStringField(value: _storage._license, fieldNumber: 18)
      }
      if !_storage._checksum.isEmpty {
        try visitor.visitSingularStringField(value: _storage._checksum, fieldNumber: 19)
      }
      if !_storage._languages.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._languages, fieldNumber: 20)
      }
      try { if let v = _storage._rules {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 21)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: FilterListManager_FullFilterList, rhs: FilterListManager_FullFilterList) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._id != rhs_storage._id {return false}
        if _storage._groupID != rhs_storage._groupID {return false}
        if _storage._timeUpdated != rhs_storage._timeUpdated {return false}
        if _storage._lastDownloadTime != rhs_storage._lastDownloadTime {return false}
        if _storage._title != rhs_storage._title {return false}
        if _storage._description_p != rhs_storage._description_p {return false}
        if _storage._version != rhs_storage._version {return false}
        if _storage._displayNumber != rhs_storage._displayNumber {return false}
        if _storage._downloadURL != rhs_storage._downloadURL {return false}
        if _storage._subscriptionURL != rhs_storage._subscriptionURL {return false}
        if _storage._tags != rhs_storage._tags {return false}
        if _storage._expires != rhs_storage._expires {return false}
        if _storage._isTrusted != rhs_storage._isTrusted {return false}
        if _storage._isCustom != rhs_storage._isCustom {return false}
        if _storage._isEnabled != rhs_storage._isEnabled {return false}
        if _storage._isInstalled != rhs_storage._isInstalled {return false}
        if _storage._homepage != rhs_storage._homepage {return false}
        if _storage._license != rhs_storage._license {return false}
        if _storage._checksum != rhs_storage._checksum {return false}
        if _storage._languages != rhs_storage._languages {return false}
        if _storage._rules != rhs_storage._rules {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
