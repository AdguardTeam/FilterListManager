// This file is @generated by prost-build.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FiltersCompilationPolicy {
    /// List of literal constants for filters conditional compilation.
    #[prost(string, repeated, tag = "1")]
    pub constants: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Configuration {
    #[prost(enumeration = "FilterListType", tag = "1")]
    pub filter_list_type: i32,
    /// Absolute path for library working directory.
    /// This will be used for database operating.
    /// If value is "None", `cwd` will be used.
    #[prost(string, optional, tag = "2")]
    pub working_directory: ::core::option::Option<::prost::alloc::string::String>,
    /// Locale that needs to be used to extract localized names and descriptions.
    /// Locale `en-GB` will be normalized to internal `en_GB` representation.
    /// Default value: en.
    #[prost(string, tag = "3")]
    pub locale: ::prost::alloc::string::String,
    /// Default period for expires in seconds (unless specified in "Expires", or its value is too small).
    /// Default value: 86400 (1 day).
    /// Values < 3600 will be clamped to 3600.
    #[prost(int32, tag = "4")]
    pub default_filter_list_expires_period_sec: i32,
    /// Settings for filters compilation or collection from compiled parts.
    ///
    /// ### Compilation
    /// During the update, each filter will be "compiled" into main filter and its includes.
    /// Main filter remains unchanged. But in includes, (include, if/else/endif) directives will be resolved, using this policy.
    /// Recursive includes will be inlined.
    ///
    /// ### Collection
    /// When you get filters, they will be collected from compiled parts (main filter + includes).
    /// All directives in main filter will be resolved, using this policy, and includes will be injected.
    #[prost(message, optional, tag = "5")]
    pub filters_compilation_policy: ::core::option::Option<FiltersCompilationPolicy>,
    /// URL of the index (filters.json) file.
    #[prost(string, tag = "6")]
    pub metadata_url: ::prost::alloc::string::String,
    /// URL of the locales (filters_i18n.json) file.
    #[prost(string, tag = "7")]
    pub metadata_locales_url: ::prost::alloc::string::String,
    /// Requests timeouts in milliseconds. Default value 60000 (60 seconds).
    #[prost(int32, tag = "8")]
    pub request_timeout_ms: i32,
    /// “Uplifting” a database is a set of measures that brings the database up to date:
    #[prost(bool, tag = "9")]
    pub auto_lift_up_database: bool,
    /// Proxy mode
    #[prost(enumeration = "RawRequestProxyMode", tag = "10")]
    pub request_proxy_mode: i32,
    /// Custom proxy addr for requests
    #[prost(string, tag = "11")]
    pub request_custom_proxy_addr: ::prost::alloc::string::String,
    /// Client app name
    #[prost(string, tag = "12")]
    pub app_name: ::prost::alloc::string::String,
    /// Client app version
    #[prost(string, tag = "13")]
    pub version: ::prost::alloc::string::String,
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum FilterListType {
    Standard = 0,
    Dns = 1,
}
impl FilterListType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Standard => "STANDARD",
            Self::Dns => "DNS",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "STANDARD" => Some(Self::Standard),
            "DNS" => Some(Self::Dns),
            _ => None,
        }
    }
}
/// FLM Requests proxy mode
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum RawRequestProxyMode {
    /// System proxy will be used
    UseSystemProxy = 0,
    /// All proxies disabled
    NoProxy = 1,
    /// Use custom proxy
    UseCustomProxy = 2,
}
impl RawRequestProxyMode {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::UseSystemProxy => "USE_SYSTEM_PROXY",
            Self::NoProxy => "NO_PROXY",
            Self::UseCustomProxy => "USE_CUSTOM_PROXY",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "USE_SYSTEM_PROXY" => Some(Self::UseSystemProxy),
            "NO_PROXY" => Some(Self::NoProxy),
            "USE_CUSTOM_PROXY" => Some(Self::UseCustomProxy),
            _ => None,
        }
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AgOuterError {
    #[prost(string, tag = "1")]
    pub message: ::prost::alloc::string::String,
    #[prost(
        oneof = "ag_outer_error::Error",
        tags = "2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19"
    )]
    pub error: ::core::option::Option<ag_outer_error::Error>,
}
/// Nested message and enum types in `AGOuterError`.
pub mod ag_outer_error {
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Error {
        #[prost(message, tag = "2")]
        CannotOpenDatabase(super::CannotOpenDatabase),
        #[prost(message, tag = "3")]
        NotADatabase(super::NotADatabase),
        #[prost(message, tag = "4")]
        DatabaseBusy(super::DatabaseBusy),
        #[prost(message, tag = "5")]
        DiskFull(super::DiskFull),
        #[prost(message, tag = "6")]
        EntityNotFound(super::EntityNotFound),
        #[prost(message, tag = "7")]
        PathNotFound(super::PathNotFound),
        #[prost(message, tag = "8")]
        PathHasDeniedPermission(super::PathHasDeniedPermission),
        #[prost(message, tag = "9")]
        PathAlreadyExists(super::PathAlreadyExists),
        #[prost(message, tag = "10")]
        TimedOut(super::TimedOut),
        #[prost(message, tag = "11")]
        HttpClientNetworkError(super::HttpClientNetworkError),
        #[prost(message, tag = "12")]
        HttpStrict200Response(super::HttpStrict200Response),
        #[prost(message, tag = "13")]
        HttpClientBodyRecoveryFailed(super::HttpClientBodyRecoveryFailed),
        #[prost(message, tag = "14")]
        FilterContentIsLikelyNotAFilter(super::FilterContentIsLikelyNotAFilter),
        #[prost(message, tag = "15")]
        FilterParserError(super::FilterParserError),
        #[prost(message, tag = "16")]
        FieldIsEmpty(super::FieldIsEmpty),
        #[prost(message, tag = "17")]
        Mutex(super::Mutex),
        #[prost(message, tag = "18")]
        InvalidConfiguration(super::InvalidConfiguration),
        #[prost(message, tag = "19")]
        Other(super::Other),
    }
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CannotOpenDatabase {}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct NotADatabase {}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct DiskFull {}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct DatabaseBusy {}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct EntityNotFound {
    #[prost(int64, tag = "1")]
    pub entity_id: i64,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PathNotFound {
    #[prost(string, tag = "1")]
    pub path: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PathHasDeniedPermission {
    #[prost(string, tag = "1")]
    pub path: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PathAlreadyExists {
    #[prost(string, tag = "1")]
    pub path: ::prost::alloc::string::String,
}
/// Do not duplicate the message
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct TimedOut {}
/// Do not duplicate the message
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct HttpClientNetworkError {}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct HttpStrict200Response {
    #[prost(uint32, tag = "1")]
    pub status_code: u32,
    #[prost(string, tag = "2")]
    pub url: ::prost::alloc::string::String,
}
/// Do not duplicate the message
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct HttpClientBodyRecoveryFailed {}
/// Do not duplicate the message
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct FilterContentIsLikelyNotAFilter {}
/// Do not duplicate the message
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct FilterParserError {}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FieldIsEmpty {
    #[prost(string, tag = "1")]
    pub field_name: ::prost::alloc::string::String,
}
/// Do not duplicate the message
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct Mutex {}
/// Do not duplicate the message
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InvalidConfiguration {
    #[prost(string, tag = "1")]
    pub msg: ::prost::alloc::string::String,
}
/// Do not duplicate the message
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct Other {}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FilterTag {
    /// Filter tag id.
    #[prost(int32, tag = "1")]
    pub id: i32,
    /// Filter keyword (purpose, lang, platform, etc.)
    #[prost(string, tag = "2")]
    pub keyword: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FilterGroup {
    /// Group id
    #[prost(int32, tag = "1")]
    pub id: i32,
    /// Group name
    #[prost(string, tag = "2")]
    pub name: ::prost::alloc::string::String,
    /// Display number for ordering
    #[prost(int32, tag = "3")]
    pub display_number: i32,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FilterListRules {
    /// Associated filter id.
    #[prost(int32, tag = "1")]
    pub filter_id: i32,
    /// List of all rules in the filter list.
    #[prost(string, repeated, tag = "2")]
    pub rules: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// List of only disabled rules.
    #[prost(string, repeated, tag = "3")]
    pub disabled_rules: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// / Rules count in this filter list. Simply a number of non-empty lines
    /// / and does not start with a comment marker.
    #[prost(int32, tag = "4")]
    pub rules_count: i32,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FilterListRulesRaw {
    /// Associated filter id.
    #[prost(int32, tag = "1")]
    pub filter_id: i32,
    /// List of all rules in the filter list as string.
    #[prost(string, tag = "2")]
    pub rules: ::prost::alloc::string::String,
    /// List of only disabled rules as string.
    #[prost(string, tag = "3")]
    pub disabled_rules: ::prost::alloc::string::String,
    /// / Rules count in this filter list. Simply a number of non-empty lines
    /// / and does not start with a comment marker.
    #[prost(int32, tag = "4")]
    pub rules_count: i32,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DisabledRulesRaw {
    /// Associated filter id.
    #[prost(int32, tag = "1")]
    pub filter_id: i32,
    /// List of only disabled rules as string.
    #[prost(string, tag = "2")]
    pub text: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FilterListMetadata {
    /// Title from the `! Title:` metadata field.
    #[prost(string, tag = "1")]
    pub title: ::prost::alloc::string::String,
    /// Description from the `! Description:` metadata field.
    #[prost(string, tag = "2")]
    pub description: ::prost::alloc::string::String,
    /// Time updated from the `! TimeUpdated:` metadata field.
    #[prost(string, tag = "3")]
    pub time_updated: ::prost::alloc::string::String,
    /// Version from the `! Version:` metadata field.
    #[prost(string, tag = "4")]
    pub version: ::prost::alloc::string::String,
    /// Homepage from the `! Homepage:` metadata field.
    #[prost(string, tag = "5")]
    pub homepage: ::prost::alloc::string::String,
    /// License from the `! License:` metadata field.
    #[prost(string, tag = "6")]
    pub license: ::prost::alloc::string::String,
    /// Checksum from the `! Checksum:` metadata field.
    #[prost(string, tag = "7")]
    pub checksum: ::prost::alloc::string::String,
    /// URL or local path where the filter content was downloaded from.
    #[prost(string, tag = "8")]
    pub url: ::prost::alloc::string::String,
    /// Rules count in this filter list.
    #[prost(int32, tag = "9")]
    pub rules_count: i32,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FilterListMetadataWithBody {
    /// Metadata for a remote filter list.
    #[prost(message, optional, tag = "1")]
    pub metadata: ::core::option::Option<FilterListMetadata>,
    /// Filter body.
    #[prost(string, tag = "2")]
    pub filter_body: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StoredFilterMetadata {
    /// Filter list unique ID
    #[prost(int32, tag = "1")]
    pub id: i32,
    /// Group ID this filter list belongs to
    #[prost(int32, tag = "2")]
    pub group_id: i32,
    /// Timestamp (seconds from epoch) when this filter was updated on the server
    #[prost(int64, tag = "3")]
    pub time_updated: i64,
    /// Timestamp (seconds from epoch) when this filter list's content was last downloaded
    #[prost(int64, tag = "4")]
    pub last_download_time: i64,
    /// Title either from the list metadata or parsed from the content
    #[prost(string, tag = "5")]
    pub title: ::prost::alloc::string::String,
    /// Description either from the list metadata or parsed from the content
    #[prost(string, tag = "6")]
    pub description: ::prost::alloc::string::String,
    /// Version either from the list metadata or parsed from the content
    #[prost(string, tag = "7")]
    pub version: ::prost::alloc::string::String,
    /// Filter list display number
    #[prost(int32, tag = "8")]
    pub display_number: i32,
    /// Filter list download URL
    #[prost(string, tag = "9")]
    pub download_url: ::prost::alloc::string::String,
    /// Filter list subscription source URL
    #[prost(string, tag = "10")]
    pub subscription_url: ::prost::alloc::string::String,
    /// An array of tags of this filter list
    #[prost(message, repeated, tag = "11")]
    pub tags: ::prost::alloc::vec::Vec<FilterTag>,
    /// Number of seconds until the filter list is considered outdated
    #[prost(int32, tag = "12")]
    pub expires: i32,
    /// Indicates if the filter list is trusted or not
    #[prost(bool, tag = "13")]
    pub is_trusted: bool,
    /// Indicates if the filter list is custom or comes from the registry
    #[prost(bool, tag = "14")]
    pub is_custom: bool,
    /// Indicates whether the filter list is enabled
    #[prost(bool, tag = "15")]
    pub is_enabled: bool,
    /// Indicates if the filter list is installed
    #[prost(bool, tag = "16")]
    pub is_installed: bool,
    /// List homepage URL
    #[prost(string, tag = "17")]
    pub homepage: ::prost::alloc::string::String,
    /// List license URL
    #[prost(string, tag = "18")]
    pub license: ::prost::alloc::string::String,
    /// Filter checksum
    #[prost(string, tag = "19")]
    pub checksum: ::prost::alloc::string::String,
    /// List of languages the filter supports
    #[prost(string, repeated, tag = "20")]
    pub languages: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FullFilterList {
    /// Filter list unique ID
    #[prost(int32, tag = "1")]
    pub id: i32,
    /// Group ID this filter list belongs to
    #[prost(int32, tag = "2")]
    pub group_id: i32,
    /// Timestamp (seconds from epoch) when this filter was updated on the server
    #[prost(int64, tag = "3")]
    pub time_updated: i64,
    /// Timestamp (seconds from epoch) when this filter list's content was last downloaded
    #[prost(int64, tag = "4")]
    pub last_download_time: i64,
    /// Title either from the list metadata or parsed from the content
    #[prost(string, tag = "5")]
    pub title: ::prost::alloc::string::String,
    /// Description either from the list metadata or parsed from the content
    #[prost(string, tag = "6")]
    pub description: ::prost::alloc::string::String,
    /// Version either from the list metadata or parsed from the content
    #[prost(string, tag = "7")]
    pub version: ::prost::alloc::string::String,
    /// Filter list display number
    #[prost(int32, tag = "8")]
    pub display_number: i32,
    /// Filter list download URL
    #[prost(string, tag = "9")]
    pub download_url: ::prost::alloc::string::String,
    /// Filter list subscription source URL
    #[prost(string, tag = "10")]
    pub subscription_url: ::prost::alloc::string::String,
    /// An array of tags of this filter list
    #[prost(message, repeated, tag = "11")]
    pub tags: ::prost::alloc::vec::Vec<FilterTag>,
    /// Number of seconds until the filter list is considered outdated
    #[prost(int32, tag = "12")]
    pub expires: i32,
    /// Indicates if the filter list is trusted or not
    #[prost(bool, tag = "13")]
    pub is_trusted: bool,
    /// Indicates if the filter list is custom or comes from the registry
    #[prost(bool, tag = "14")]
    pub is_custom: bool,
    /// Indicates whether the filter list is enabled
    #[prost(bool, tag = "15")]
    pub is_enabled: bool,
    /// Indicates if the filter list is installed
    #[prost(bool, tag = "16")]
    pub is_installed: bool,
    /// List homepage URL
    #[prost(string, tag = "17")]
    pub homepage: ::prost::alloc::string::String,
    /// List license URL
    #[prost(string, tag = "18")]
    pub license: ::prost::alloc::string::String,
    /// Filter checksum
    #[prost(string, tag = "19")]
    pub checksum: ::prost::alloc::string::String,
    /// List of languages the filter supports
    #[prost(string, repeated, tag = "20")]
    pub languages: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Optional container for rules
    #[prost(message, optional, tag = "21")]
    pub rules: ::core::option::Option<FilterListRules>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct RulesCountByFilter {
    /// Associated filter id.
    #[prost(int32, tag = "1")]
    pub filter_id: i32,
    /// Rules count in this filter list. Simply a number of non-empty lines
    /// and does not start with a comment marker.
    #[prost(int32, tag = "2")]
    pub rules_count: i32,
}
/// ActiveRulesInfo
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ActiveRulesInfo {
    /// Filter id for these rules
    #[prost(int32, tag = "1")]
    pub filter_id: i32,
    /// Group id of the filter
    #[prost(int32, tag = "2")]
    pub group_id: i32,
    /// Is this filter trusted?
    #[prost(bool, tag = "3")]
    pub is_trusted: bool,
    /// List of active rules.
    #[prost(string, repeated, tag = "4")]
    pub rules: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// UpdateResult
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateResult {
    /// Currently updated filters.
    #[prost(message, repeated, tag = "1")]
    pub updated_list: ::prost::alloc::vec::Vec<FullFilterList>,
    /// Number of filters not updated due to timeout.
    #[prost(int32, tag = "2")]
    pub remaining_filters_count: i32,
    /// List of entities containing the filter id and a string representation of the error
    #[prost(message, repeated, tag = "3")]
    pub filters_errors: ::prost::alloc::vec::Vec<UpdateFilterError>,
}
/// UpdateFilterError
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateFilterError {
    /// ID of that filter that couldn't be updated
    #[prost(int32, tag = "1")]
    pub filter_id: i32,
    /// Filter error converted to a string. For debugging purposes
    #[prost(string, tag = "2")]
    pub message: ::prost::alloc::string::String,
    /// Filter url
    #[prost(string, optional, tag = "3")]
    pub filter_url: ::core::option::Option<::prost::alloc::string::String>,
    /// Http client error
    #[prost(string, optional, tag = "4")]
    pub http_client_error: ::core::option::Option<::prost::alloc::string::String>,
}
/// Information about filter movement during index metadata update
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MovedFilterInfo {
    /// / Previous id of the filter
    #[prost(int32, tag = "1")]
    pub previous_id: i32,
    /// / New id of the filter
    #[prost(int32, tag = "2")]
    pub new_id: i32,
}
/// Result of index metadata update
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PullMetadataResult {
    /// List of filters added in the update
    #[prost(int32, repeated, tag = "1")]
    pub added_filters: ::prost::alloc::vec::Vec<i32>,
    /// List of filters removed in the update
    #[prost(int32, repeated, tag = "2")]
    pub removed_filters: ::prost::alloc::vec::Vec<i32>,
    /// List of filters moved in the update
    #[prost(message, repeated, tag = "3")]
    pub moved_filters: ::prost::alloc::vec::Vec<MovedFilterInfo>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InstallCustomFilterListRequest {
    #[prost(string, tag = "1")]
    pub download_url: ::prost::alloc::string::String,
    #[prost(bool, tag = "2")]
    pub is_trusted: bool,
    #[prost(string, optional, tag = "3")]
    pub title: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "4")]
    pub description: ::core::option::Option<::prost::alloc::string::String>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InstallCustomFilterFromStringRequest {
    #[prost(string, tag = "1")]
    pub download_url: ::prost::alloc::string::String,
    #[prost(int64, tag = "2")]
    pub last_download_time: i64,
    #[prost(bool, tag = "3")]
    pub is_enabled: bool,
    #[prost(bool, tag = "4")]
    pub is_trusted: bool,
    #[prost(string, tag = "5")]
    pub filter_body: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "6")]
    pub custom_title: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "7")]
    pub custom_description: ::core::option::Option<::prost::alloc::string::String>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EnableFilterListsRequest {
    #[prost(int32, repeated, tag = "1")]
    pub ids: ::prost::alloc::vec::Vec<i32>,
    #[prost(bool, tag = "2")]
    pub is_enabled: bool,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InstallFilterListsRequest {
    #[prost(int32, repeated, tag = "1")]
    pub ids: ::prost::alloc::vec::Vec<i32>,
    #[prost(bool, tag = "2")]
    pub is_installed: bool,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteCustomFilterListsRequest {
    #[prost(int32, repeated, tag = "1")]
    pub ids: ::prost::alloc::vec::Vec<i32>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GetFullFilterListByIdRequest {
    #[prost(int32, tag = "1")]
    pub id: i32,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GetStoredFilterMetadataByIdRequest {
    #[prost(int32, tag = "1")]
    pub id: i32,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SaveCustomFilterRulesRequest {
    #[prost(message, optional, tag = "1")]
    pub rules: ::core::option::Option<FilterListRules>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SaveDisabledRulesRequest {
    #[prost(int32, tag = "1")]
    pub filter_id: i32,
    #[prost(string, repeated, tag = "2")]
    pub disabled_rules: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct UpdateFiltersRequest {
    #[prost(bool, tag = "1")]
    pub ignore_filters_expiration: bool,
    #[prost(int32, tag = "2")]
    pub loose_timeout: i32,
    #[prost(bool, tag = "3")]
    pub ignore_filters_status: bool,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ForceUpdateFiltersByIdsRequest {
    #[prost(int32, repeated, tag = "1")]
    pub ids: ::prost::alloc::vec::Vec<i32>,
    #[prost(int32, tag = "2")]
    pub loose_timeout: i32,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FetchFilterListMetadataRequest {
    #[prost(string, tag = "1")]
    pub url: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FetchFilterListMetadataWithBodyRequest {
    #[prost(string, tag = "1")]
    pub url: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ChangeLocaleRequest {
    #[prost(string, tag = "1")]
    pub suggested_locale: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateCustomFilterMetadataRequest {
    #[prost(int32, tag = "1")]
    pub filter_id: i32,
    #[prost(string, tag = "2")]
    pub title: ::prost::alloc::string::String,
    #[prost(bool, tag = "3")]
    pub is_trusted: bool,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetFilterRulesAsStringsRequest {
    #[prost(int32, repeated, tag = "1")]
    pub ids: ::prost::alloc::vec::Vec<i32>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SaveRulesToFileBlobRequest {
    #[prost(int32, tag = "1")]
    pub filter_id: i32,
    #[prost(string, tag = "2")]
    pub file_path: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetDisabledRulesRequest {
    #[prost(int32, repeated, tag = "1")]
    pub ids: ::prost::alloc::vec::Vec<i32>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SetProxyModeRequest {
    #[prost(enumeration = "RawRequestProxyMode", tag = "1")]
    pub mode: i32,
    #[prost(string, tag = "2")]
    pub custom_proxy_addr: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetRulesCountRequest {
    #[prost(int32, repeated, tag = "1")]
    pub ids: ::prost::alloc::vec::Vec<i32>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct EmptyRequest {}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InstallCustomFilterListResponse {
    #[prost(message, optional, tag = "1")]
    pub filter_list: ::core::option::Option<FullFilterList>,
    #[prost(message, optional, tag = "2")]
    pub error: ::core::option::Option<AgOuterError>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EnableFilterListsResponse {
    #[prost(int64, tag = "1")]
    pub count: i64,
    #[prost(message, optional, tag = "2")]
    pub error: ::core::option::Option<AgOuterError>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InstallFilterListsResponse {
    #[prost(int64, tag = "1")]
    pub count: i64,
    #[prost(message, optional, tag = "2")]
    pub error: ::core::option::Option<AgOuterError>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteCustomFilterListsResponse {
    #[prost(int64, tag = "1")]
    pub count: i64,
    #[prost(message, optional, tag = "2")]
    pub error: ::core::option::Option<AgOuterError>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetStoredFiltersMetadataResponse {
    #[prost(message, repeated, tag = "1")]
    pub filter_lists: ::prost::alloc::vec::Vec<StoredFilterMetadata>,
    #[prost(message, optional, tag = "2")]
    pub error: ::core::option::Option<AgOuterError>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetStoredFilterMetadataByIdResponse {
    #[prost(message, optional, tag = "1")]
    pub filter_list: ::core::option::Option<StoredFilterMetadata>,
    #[prost(message, optional, tag = "2")]
    pub error: ::core::option::Option<AgOuterError>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetFullFilterListByIdResponse {
    #[prost(message, optional, tag = "1")]
    pub filter_list: ::core::option::Option<FullFilterList>,
    #[prost(message, optional, tag = "2")]
    pub error: ::core::option::Option<AgOuterError>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateFiltersResponse {
    #[prost(message, optional, tag = "1")]
    pub result: ::core::option::Option<UpdateResult>,
    #[prost(message, optional, tag = "2")]
    pub error: ::core::option::Option<AgOuterError>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ForceUpdateFiltersByIdsResponse {
    #[prost(message, optional, tag = "1")]
    pub result: ::core::option::Option<UpdateResult>,
    #[prost(message, optional, tag = "2")]
    pub error: ::core::option::Option<AgOuterError>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FetchFilterListMetadataResponse {
    #[prost(message, optional, tag = "1")]
    pub metadata: ::core::option::Option<FilterListMetadata>,
    #[prost(message, optional, tag = "2")]
    pub error: ::core::option::Option<AgOuterError>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FetchFilterListMetadataWithBodyResponse {
    #[prost(message, optional, tag = "1")]
    pub metadata: ::core::option::Option<FilterListMetadataWithBody>,
    #[prost(message, optional, tag = "2")]
    pub error: ::core::option::Option<AgOuterError>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetAllTagsResponse {
    #[prost(message, repeated, tag = "1")]
    pub tags: ::prost::alloc::vec::Vec<FilterTag>,
    #[prost(message, optional, tag = "2")]
    pub error: ::core::option::Option<AgOuterError>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetAllGroupsResponse {
    #[prost(message, repeated, tag = "1")]
    pub groups: ::prost::alloc::vec::Vec<FilterGroup>,
    #[prost(message, optional, tag = "2")]
    pub error: ::core::option::Option<AgOuterError>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ChangeLocaleResponse {
    #[prost(bool, tag = "1")]
    pub success: bool,
    #[prost(message, optional, tag = "2")]
    pub error: ::core::option::Option<AgOuterError>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateCustomFilterMetadataResponse {
    #[prost(bool, tag = "1")]
    pub success: bool,
    #[prost(message, optional, tag = "2")]
    pub error: ::core::option::Option<AgOuterError>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetDatabasePathResponse {
    #[prost(string, tag = "1")]
    pub path: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub error: ::core::option::Option<AgOuterError>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetDatabaseVersionResponse {
    #[prost(int32, optional, tag = "1")]
    pub version: ::core::option::Option<i32>,
    #[prost(message, optional, tag = "2")]
    pub error: ::core::option::Option<AgOuterError>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InstallCustomFilterFromStringResponse {
    #[prost(message, optional, tag = "1")]
    pub filter_list: ::core::option::Option<FullFilterList>,
    #[prost(message, optional, tag = "2")]
    pub error: ::core::option::Option<AgOuterError>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetActiveRulesResponse {
    #[prost(message, repeated, tag = "1")]
    pub rules: ::prost::alloc::vec::Vec<ActiveRulesInfo>,
    #[prost(message, optional, tag = "2")]
    pub error: ::core::option::Option<AgOuterError>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetFilterRulesAsStringsResponse {
    #[prost(message, repeated, tag = "1")]
    pub rules_list: ::prost::alloc::vec::Vec<FilterListRulesRaw>,
    #[prost(message, optional, tag = "2")]
    pub error: ::core::option::Option<AgOuterError>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetDisabledRulesResponse {
    #[prost(message, repeated, tag = "1")]
    pub rules_raw: ::prost::alloc::vec::Vec<DisabledRulesRaw>,
    #[prost(message, optional, tag = "2")]
    pub error: ::core::option::Option<AgOuterError>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetRulesCountResponse {
    #[prost(message, repeated, tag = "1")]
    pub rules_count_by_filter: ::prost::alloc::vec::Vec<RulesCountByFilter>,
    #[prost(message, optional, tag = "2")]
    pub error: ::core::option::Option<AgOuterError>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PullMetadataResponse {
    #[prost(message, optional, tag = "1")]
    pub result: ::core::option::Option<PullMetadataResult>,
    #[prost(message, optional, tag = "2")]
    pub error: ::core::option::Option<AgOuterError>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EmptyResponse {
    #[prost(message, optional, tag = "1")]
    pub error: ::core::option::Option<AgOuterError>,
}
