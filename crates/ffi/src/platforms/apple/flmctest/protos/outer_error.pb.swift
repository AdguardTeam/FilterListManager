// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: outer_error.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

struct FilterListManager_AGOuterError {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var message: String = String()

  var error: FilterListManager_AGOuterError.OneOf_Error? = nil

  var cannotOpenDatabase: FilterListManager_CannotOpenDatabase {
    get {
      if case .cannotOpenDatabase(let v)? = error {return v}
      return FilterListManager_CannotOpenDatabase()
    }
    set {error = .cannotOpenDatabase(newValue)}
  }

  var notADatabase: FilterListManager_NotADatabase {
    get {
      if case .notADatabase(let v)? = error {return v}
      return FilterListManager_NotADatabase()
    }
    set {error = .notADatabase(newValue)}
  }

  var databaseBusy: FilterListManager_DatabaseBusy {
    get {
      if case .databaseBusy(let v)? = error {return v}
      return FilterListManager_DatabaseBusy()
    }
    set {error = .databaseBusy(newValue)}
  }

  var diskFull: FilterListManager_DiskFull {
    get {
      if case .diskFull(let v)? = error {return v}
      return FilterListManager_DiskFull()
    }
    set {error = .diskFull(newValue)}
  }

  var entityNotFound: FilterListManager_EntityNotFound {
    get {
      if case .entityNotFound(let v)? = error {return v}
      return FilterListManager_EntityNotFound()
    }
    set {error = .entityNotFound(newValue)}
  }

  var pathNotFound: FilterListManager_PathNotFound {
    get {
      if case .pathNotFound(let v)? = error {return v}
      return FilterListManager_PathNotFound()
    }
    set {error = .pathNotFound(newValue)}
  }

  var pathHasDeniedPermission: FilterListManager_PathHasDeniedPermission {
    get {
      if case .pathHasDeniedPermission(let v)? = error {return v}
      return FilterListManager_PathHasDeniedPermission()
    }
    set {error = .pathHasDeniedPermission(newValue)}
  }

  var pathAlreadyExists: FilterListManager_PathAlreadyExists {
    get {
      if case .pathAlreadyExists(let v)? = error {return v}
      return FilterListManager_PathAlreadyExists()
    }
    set {error = .pathAlreadyExists(newValue)}
  }

  var timedOut: FilterListManager_TimedOut {
    get {
      if case .timedOut(let v)? = error {return v}
      return FilterListManager_TimedOut()
    }
    set {error = .timedOut(newValue)}
  }

  var httpClientNetworkError: FilterListManager_HttpClientNetworkError {
    get {
      if case .httpClientNetworkError(let v)? = error {return v}
      return FilterListManager_HttpClientNetworkError()
    }
    set {error = .httpClientNetworkError(newValue)}
  }

  var httpStrict200Response: FilterListManager_HttpStrict200Response {
    get {
      if case .httpStrict200Response(let v)? = error {return v}
      return FilterListManager_HttpStrict200Response()
    }
    set {error = .httpStrict200Response(newValue)}
  }

  var httpClientBodyRecoveryFailed: FilterListManager_HttpClientBodyRecoveryFailed {
    get {
      if case .httpClientBodyRecoveryFailed(let v)? = error {return v}
      return FilterListManager_HttpClientBodyRecoveryFailed()
    }
    set {error = .httpClientBodyRecoveryFailed(newValue)}
  }

  var filterContentIsLikelyNotAFilter: FilterListManager_FilterContentIsLikelyNotAFilter {
    get {
      if case .filterContentIsLikelyNotAFilter(let v)? = error {return v}
      return FilterListManager_FilterContentIsLikelyNotAFilter()
    }
    set {error = .filterContentIsLikelyNotAFilter(newValue)}
  }

  var filterParserError: FilterListManager_FilterParserError {
    get {
      if case .filterParserError(let v)? = error {return v}
      return FilterListManager_FilterParserError()
    }
    set {error = .filterParserError(newValue)}
  }

  var fieldIsEmpty: FilterListManager_FieldIsEmpty {
    get {
      if case .fieldIsEmpty(let v)? = error {return v}
      return FilterListManager_FieldIsEmpty()
    }
    set {error = .fieldIsEmpty(newValue)}
  }

  var mutex: FilterListManager_Mutex {
    get {
      if case .mutex(let v)? = error {return v}
      return FilterListManager_Mutex()
    }
    set {error = .mutex(newValue)}
  }

  var other: FilterListManager_Other {
    get {
      if case .other(let v)? = error {return v}
      return FilterListManager_Other()
    }
    set {error = .other(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Error: Equatable {
    case cannotOpenDatabase(FilterListManager_CannotOpenDatabase)
    case notADatabase(FilterListManager_NotADatabase)
    case databaseBusy(FilterListManager_DatabaseBusy)
    case diskFull(FilterListManager_DiskFull)
    case entityNotFound(FilterListManager_EntityNotFound)
    case pathNotFound(FilterListManager_PathNotFound)
    case pathHasDeniedPermission(FilterListManager_PathHasDeniedPermission)
    case pathAlreadyExists(FilterListManager_PathAlreadyExists)
    case timedOut(FilterListManager_TimedOut)
    case httpClientNetworkError(FilterListManager_HttpClientNetworkError)
    case httpStrict200Response(FilterListManager_HttpStrict200Response)
    case httpClientBodyRecoveryFailed(FilterListManager_HttpClientBodyRecoveryFailed)
    case filterContentIsLikelyNotAFilter(FilterListManager_FilterContentIsLikelyNotAFilter)
    case filterParserError(FilterListManager_FilterParserError)
    case fieldIsEmpty(FilterListManager_FieldIsEmpty)
    case mutex(FilterListManager_Mutex)
    case other(FilterListManager_Other)

  #if !swift(>=4.1)
    static func ==(lhs: FilterListManager_AGOuterError.OneOf_Error, rhs: FilterListManager_AGOuterError.OneOf_Error) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.cannotOpenDatabase, .cannotOpenDatabase): return {
        guard case .cannotOpenDatabase(let l) = lhs, case .cannotOpenDatabase(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.notADatabase, .notADatabase): return {
        guard case .notADatabase(let l) = lhs, case .notADatabase(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.databaseBusy, .databaseBusy): return {
        guard case .databaseBusy(let l) = lhs, case .databaseBusy(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.diskFull, .diskFull): return {
        guard case .diskFull(let l) = lhs, case .diskFull(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.entityNotFound, .entityNotFound): return {
        guard case .entityNotFound(let l) = lhs, case .entityNotFound(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.pathNotFound, .pathNotFound): return {
        guard case .pathNotFound(let l) = lhs, case .pathNotFound(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.pathHasDeniedPermission, .pathHasDeniedPermission): return {
        guard case .pathHasDeniedPermission(let l) = lhs, case .pathHasDeniedPermission(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.pathAlreadyExists, .pathAlreadyExists): return {
        guard case .pathAlreadyExists(let l) = lhs, case .pathAlreadyExists(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.timedOut, .timedOut): return {
        guard case .timedOut(let l) = lhs, case .timedOut(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.httpClientNetworkError, .httpClientNetworkError): return {
        guard case .httpClientNetworkError(let l) = lhs, case .httpClientNetworkError(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.httpStrict200Response, .httpStrict200Response): return {
        guard case .httpStrict200Response(let l) = lhs, case .httpStrict200Response(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.httpClientBodyRecoveryFailed, .httpClientBodyRecoveryFailed): return {
        guard case .httpClientBodyRecoveryFailed(let l) = lhs, case .httpClientBodyRecoveryFailed(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.filterContentIsLikelyNotAFilter, .filterContentIsLikelyNotAFilter): return {
        guard case .filterContentIsLikelyNotAFilter(let l) = lhs, case .filterContentIsLikelyNotAFilter(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.filterParserError, .filterParserError): return {
        guard case .filterParserError(let l) = lhs, case .filterParserError(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.fieldIsEmpty, .fieldIsEmpty): return {
        guard case .fieldIsEmpty(let l) = lhs, case .fieldIsEmpty(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.mutex, .mutex): return {
        guard case .mutex(let l) = lhs, case .mutex(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.other, .other): return {
        guard case .other(let l) = lhs, case .other(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  init() {}
}

struct FilterListManager_CannotOpenDatabase {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct FilterListManager_NotADatabase {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct FilterListManager_DiskFull {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct FilterListManager_DatabaseBusy {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct FilterListManager_EntityNotFound {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var entityID: Int64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct FilterListManager_PathNotFound {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var path: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct FilterListManager_PathHasDeniedPermission {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var path: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct FilterListManager_PathAlreadyExists {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var path: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Do not duplicate the message
struct FilterListManager_TimedOut {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Do not duplicate the message
struct FilterListManager_HttpClientNetworkError {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct FilterListManager_HttpStrict200Response {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var statusCode: UInt32 = 0

  var url: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Do not duplicate the message
struct FilterListManager_HttpClientBodyRecoveryFailed {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Do not duplicate the message
struct FilterListManager_FilterContentIsLikelyNotAFilter {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Do not duplicate the message
struct FilterListManager_FilterParserError {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct FilterListManager_FieldIsEmpty {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var fieldName: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Do not duplicate the message
struct FilterListManager_Mutex {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Do not duplicate the message
struct FilterListManager_Other {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

#if swift(>=5.5) && canImport(_Concurrency)
extension FilterListManager_AGOuterError: @unchecked Sendable {}
extension FilterListManager_AGOuterError.OneOf_Error: @unchecked Sendable {}
extension FilterListManager_CannotOpenDatabase: @unchecked Sendable {}
extension FilterListManager_NotADatabase: @unchecked Sendable {}
extension FilterListManager_DiskFull: @unchecked Sendable {}
extension FilterListManager_DatabaseBusy: @unchecked Sendable {}
extension FilterListManager_EntityNotFound: @unchecked Sendable {}
extension FilterListManager_PathNotFound: @unchecked Sendable {}
extension FilterListManager_PathHasDeniedPermission: @unchecked Sendable {}
extension FilterListManager_PathAlreadyExists: @unchecked Sendable {}
extension FilterListManager_TimedOut: @unchecked Sendable {}
extension FilterListManager_HttpClientNetworkError: @unchecked Sendable {}
extension FilterListManager_HttpStrict200Response: @unchecked Sendable {}
extension FilterListManager_HttpClientBodyRecoveryFailed: @unchecked Sendable {}
extension FilterListManager_FilterContentIsLikelyNotAFilter: @unchecked Sendable {}
extension FilterListManager_FilterParserError: @unchecked Sendable {}
extension FilterListManager_FieldIsEmpty: @unchecked Sendable {}
extension FilterListManager_Mutex: @unchecked Sendable {}
extension FilterListManager_Other: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "filter_list_manager"

extension FilterListManager_AGOuterError: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AGOuterError"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "message"),
    2: .standard(proto: "cannot_open_database"),
    3: .standard(proto: "not_a_database"),
    4: .standard(proto: "database_busy"),
    5: .standard(proto: "disk_full"),
    6: .standard(proto: "entity_not_found"),
    7: .standard(proto: "path_not_found"),
    8: .standard(proto: "path_has_denied_permission"),
    9: .standard(proto: "path_already_exists"),
    10: .standard(proto: "timed_out"),
    11: .standard(proto: "http_client_network_error"),
    12: .standard(proto: "http_strict_200_response"),
    13: .standard(proto: "http_client_body_recovery_failed"),
    14: .standard(proto: "filter_content_is_likely_not_a_filter"),
    15: .standard(proto: "filter_parser_error"),
    16: .standard(proto: "field_is_empty"),
    17: .same(proto: "mutex"),
    18: .same(proto: "other"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.message) }()
      case 2: try {
        var v: FilterListManager_CannotOpenDatabase?
        var hadOneofValue = false
        if let current = self.error {
          hadOneofValue = true
          if case .cannotOpenDatabase(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.error = .cannotOpenDatabase(v)
        }
      }()
      case 3: try {
        var v: FilterListManager_NotADatabase?
        var hadOneofValue = false
        if let current = self.error {
          hadOneofValue = true
          if case .notADatabase(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.error = .notADatabase(v)
        }
      }()
      case 4: try {
        var v: FilterListManager_DatabaseBusy?
        var hadOneofValue = false
        if let current = self.error {
          hadOneofValue = true
          if case .databaseBusy(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.error = .databaseBusy(v)
        }
      }()
      case 5: try {
        var v: FilterListManager_DiskFull?
        var hadOneofValue = false
        if let current = self.error {
          hadOneofValue = true
          if case .diskFull(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.error = .diskFull(v)
        }
      }()
      case 6: try {
        var v: FilterListManager_EntityNotFound?
        var hadOneofValue = false
        if let current = self.error {
          hadOneofValue = true
          if case .entityNotFound(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.error = .entityNotFound(v)
        }
      }()
      case 7: try {
        var v: FilterListManager_PathNotFound?
        var hadOneofValue = false
        if let current = self.error {
          hadOneofValue = true
          if case .pathNotFound(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.error = .pathNotFound(v)
        }
      }()
      case 8: try {
        var v: FilterListManager_PathHasDeniedPermission?
        var hadOneofValue = false
        if let current = self.error {
          hadOneofValue = true
          if case .pathHasDeniedPermission(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.error = .pathHasDeniedPermission(v)
        }
      }()
      case 9: try {
        var v: FilterListManager_PathAlreadyExists?
        var hadOneofValue = false
        if let current = self.error {
          hadOneofValue = true
          if case .pathAlreadyExists(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.error = .pathAlreadyExists(v)
        }
      }()
      case 10: try {
        var v: FilterListManager_TimedOut?
        var hadOneofValue = false
        if let current = self.error {
          hadOneofValue = true
          if case .timedOut(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.error = .timedOut(v)
        }
      }()
      case 11: try {
        var v: FilterListManager_HttpClientNetworkError?
        var hadOneofValue = false
        if let current = self.error {
          hadOneofValue = true
          if case .httpClientNetworkError(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.error = .httpClientNetworkError(v)
        }
      }()
      case 12: try {
        var v: FilterListManager_HttpStrict200Response?
        var hadOneofValue = false
        if let current = self.error {
          hadOneofValue = true
          if case .httpStrict200Response(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.error = .httpStrict200Response(v)
        }
      }()
      case 13: try {
        var v: FilterListManager_HttpClientBodyRecoveryFailed?
        var hadOneofValue = false
        if let current = self.error {
          hadOneofValue = true
          if case .httpClientBodyRecoveryFailed(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.error = .httpClientBodyRecoveryFailed(v)
        }
      }()
      case 14: try {
        var v: FilterListManager_FilterContentIsLikelyNotAFilter?
        var hadOneofValue = false
        if let current = self.error {
          hadOneofValue = true
          if case .filterContentIsLikelyNotAFilter(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.error = .filterContentIsLikelyNotAFilter(v)
        }
      }()
      case 15: try {
        var v: FilterListManager_FilterParserError?
        var hadOneofValue = false
        if let current = self.error {
          hadOneofValue = true
          if case .filterParserError(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.error = .filterParserError(v)
        }
      }()
      case 16: try {
        var v: FilterListManager_FieldIsEmpty?
        var hadOneofValue = false
        if let current = self.error {
          hadOneofValue = true
          if case .fieldIsEmpty(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.error = .fieldIsEmpty(v)
        }
      }()
      case 17: try {
        var v: FilterListManager_Mutex?
        var hadOneofValue = false
        if let current = self.error {
          hadOneofValue = true
          if case .mutex(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.error = .mutex(v)
        }
      }()
      case 18: try {
        var v: FilterListManager_Other?
        var hadOneofValue = false
        if let current = self.error {
          hadOneofValue = true
          if case .other(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.error = .other(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 1)
    }
    switch self.error {
    case .cannotOpenDatabase?: try {
      guard case .cannotOpenDatabase(let v)? = self.error else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .notADatabase?: try {
      guard case .notADatabase(let v)? = self.error else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .databaseBusy?: try {
      guard case .databaseBusy(let v)? = self.error else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .diskFull?: try {
      guard case .diskFull(let v)? = self.error else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case .entityNotFound?: try {
      guard case .entityNotFound(let v)? = self.error else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }()
    case .pathNotFound?: try {
      guard case .pathNotFound(let v)? = self.error else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }()
    case .pathHasDeniedPermission?: try {
      guard case .pathHasDeniedPermission(let v)? = self.error else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    }()
    case .pathAlreadyExists?: try {
      guard case .pathAlreadyExists(let v)? = self.error else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
    }()
    case .timedOut?: try {
      guard case .timedOut(let v)? = self.error else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
    }()
    case .httpClientNetworkError?: try {
      guard case .httpClientNetworkError(let v)? = self.error else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
    }()
    case .httpStrict200Response?: try {
      guard case .httpStrict200Response(let v)? = self.error else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
    }()
    case .httpClientBodyRecoveryFailed?: try {
      guard case .httpClientBodyRecoveryFailed(let v)? = self.error else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
    }()
    case .filterContentIsLikelyNotAFilter?: try {
      guard case .filterContentIsLikelyNotAFilter(let v)? = self.error else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 14)
    }()
    case .filterParserError?: try {
      guard case .filterParserError(let v)? = self.error else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
    }()
    case .fieldIsEmpty?: try {
      guard case .fieldIsEmpty(let v)? = self.error else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 16)
    }()
    case .mutex?: try {
      guard case .mutex(let v)? = self.error else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 17)
    }()
    case .other?: try {
      guard case .other(let v)? = self.error else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 18)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: FilterListManager_AGOuterError, rhs: FilterListManager_AGOuterError) -> Bool {
    if lhs.message != rhs.message {return false}
    if lhs.error != rhs.error {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension FilterListManager_CannotOpenDatabase: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CannotOpenDatabase"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: FilterListManager_CannotOpenDatabase, rhs: FilterListManager_CannotOpenDatabase) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension FilterListManager_NotADatabase: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".NotADatabase"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: FilterListManager_NotADatabase, rhs: FilterListManager_NotADatabase) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension FilterListManager_DiskFull: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DiskFull"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: FilterListManager_DiskFull, rhs: FilterListManager_DiskFull) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension FilterListManager_DatabaseBusy: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DatabaseBusy"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: FilterListManager_DatabaseBusy, rhs: FilterListManager_DatabaseBusy) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension FilterListManager_EntityNotFound: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".EntityNotFound"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "entity_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.entityID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.entityID != 0 {
      try visitor.visitSingularInt64Field(value: self.entityID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: FilterListManager_EntityNotFound, rhs: FilterListManager_EntityNotFound) -> Bool {
    if lhs.entityID != rhs.entityID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension FilterListManager_PathNotFound: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PathNotFound"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "path"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.path) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.path.isEmpty {
      try visitor.visitSingularStringField(value: self.path, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: FilterListManager_PathNotFound, rhs: FilterListManager_PathNotFound) -> Bool {
    if lhs.path != rhs.path {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension FilterListManager_PathHasDeniedPermission: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PathHasDeniedPermission"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "path"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.path) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.path.isEmpty {
      try visitor.visitSingularStringField(value: self.path, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: FilterListManager_PathHasDeniedPermission, rhs: FilterListManager_PathHasDeniedPermission) -> Bool {
    if lhs.path != rhs.path {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension FilterListManager_PathAlreadyExists: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PathAlreadyExists"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "path"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.path) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.path.isEmpty {
      try visitor.visitSingularStringField(value: self.path, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: FilterListManager_PathAlreadyExists, rhs: FilterListManager_PathAlreadyExists) -> Bool {
    if lhs.path != rhs.path {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension FilterListManager_TimedOut: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TimedOut"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: FilterListManager_TimedOut, rhs: FilterListManager_TimedOut) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension FilterListManager_HttpClientNetworkError: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".HttpClientNetworkError"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: FilterListManager_HttpClientNetworkError, rhs: FilterListManager_HttpClientNetworkError) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension FilterListManager_HttpStrict200Response: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".HttpStrict200Response"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "status_code"),
    2: .same(proto: "url"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.statusCode) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.url) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.statusCode != 0 {
      try visitor.visitSingularUInt32Field(value: self.statusCode, fieldNumber: 1)
    }
    if !self.url.isEmpty {
      try visitor.visitSingularStringField(value: self.url, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: FilterListManager_HttpStrict200Response, rhs: FilterListManager_HttpStrict200Response) -> Bool {
    if lhs.statusCode != rhs.statusCode {return false}
    if lhs.url != rhs.url {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension FilterListManager_HttpClientBodyRecoveryFailed: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".HttpClientBodyRecoveryFailed"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: FilterListManager_HttpClientBodyRecoveryFailed, rhs: FilterListManager_HttpClientBodyRecoveryFailed) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension FilterListManager_FilterContentIsLikelyNotAFilter: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".FilterContentIsLikelyNotAFilter"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: FilterListManager_FilterContentIsLikelyNotAFilter, rhs: FilterListManager_FilterContentIsLikelyNotAFilter) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension FilterListManager_FilterParserError: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".FilterParserError"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: FilterListManager_FilterParserError, rhs: FilterListManager_FilterParserError) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension FilterListManager_FieldIsEmpty: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".FieldIsEmpty"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "field_name"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.fieldName) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.fieldName.isEmpty {
      try visitor.visitSingularStringField(value: self.fieldName, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: FilterListManager_FieldIsEmpty, rhs: FilterListManager_FieldIsEmpty) -> Bool {
    if lhs.fieldName != rhs.fieldName {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension FilterListManager_Mutex: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Mutex"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: FilterListManager_Mutex, rhs: FilterListManager_Mutex) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension FilterListManager_Other: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Other"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: FilterListManager_Other, rhs: FilterListManager_Other) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
