// DO NOT EDIT.
// swift-format-ignore-file
// swiftlint:disable all
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: outer_error.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

public struct FilterListManager_AGOuterError: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var message: String = String()

  public var error: FilterListManager_AGOuterError.OneOf_Error? = nil

  public var cannotOpenDatabase: FilterListManager_CannotOpenDatabase {
    get {
      if case .cannotOpenDatabase(let v)? = error {return v}
      return FilterListManager_CannotOpenDatabase()
    }
    set {error = .cannotOpenDatabase(newValue)}
  }

  public var notADatabase: FilterListManager_NotADatabase {
    get {
      if case .notADatabase(let v)? = error {return v}
      return FilterListManager_NotADatabase()
    }
    set {error = .notADatabase(newValue)}
  }

  public var databaseBusy: FilterListManager_DatabaseBusy {
    get {
      if case .databaseBusy(let v)? = error {return v}
      return FilterListManager_DatabaseBusy()
    }
    set {error = .databaseBusy(newValue)}
  }

  public var diskFull: FilterListManager_DiskFull {
    get {
      if case .diskFull(let v)? = error {return v}
      return FilterListManager_DiskFull()
    }
    set {error = .diskFull(newValue)}
  }

  public var entityNotFound: FilterListManager_EntityNotFound {
    get {
      if case .entityNotFound(let v)? = error {return v}
      return FilterListManager_EntityNotFound()
    }
    set {error = .entityNotFound(newValue)}
  }

  public var pathNotFound: FilterListManager_PathNotFound {
    get {
      if case .pathNotFound(let v)? = error {return v}
      return FilterListManager_PathNotFound()
    }
    set {error = .pathNotFound(newValue)}
  }

  public var pathHasDeniedPermission: FilterListManager_PathHasDeniedPermission {
    get {
      if case .pathHasDeniedPermission(let v)? = error {return v}
      return FilterListManager_PathHasDeniedPermission()
    }
    set {error = .pathHasDeniedPermission(newValue)}
  }

  public var pathAlreadyExists: FilterListManager_PathAlreadyExists {
    get {
      if case .pathAlreadyExists(let v)? = error {return v}
      return FilterListManager_PathAlreadyExists()
    }
    set {error = .pathAlreadyExists(newValue)}
  }

  public var timedOut: FilterListManager_TimedOut {
    get {
      if case .timedOut(let v)? = error {return v}
      return FilterListManager_TimedOut()
    }
    set {error = .timedOut(newValue)}
  }

  public var httpClientNetworkError: FilterListManager_HttpClientNetworkError {
    get {
      if case .httpClientNetworkError(let v)? = error {return v}
      return FilterListManager_HttpClientNetworkError()
    }
    set {error = .httpClientNetworkError(newValue)}
  }

  public var httpStrict200Response: FilterListManager_HttpStrict200Response {
    get {
      if case .httpStrict200Response(let v)? = error {return v}
      return FilterListManager_HttpStrict200Response()
    }
    set {error = .httpStrict200Response(newValue)}
  }

  public var httpClientBodyRecoveryFailed: FilterListManager_HttpClientBodyRecoveryFailed {
    get {
      if case .httpClientBodyRecoveryFailed(let v)? = error {return v}
      return FilterListManager_HttpClientBodyRecoveryFailed()
    }
    set {error = .httpClientBodyRecoveryFailed(newValue)}
  }

  public var filterContentIsLikelyNotAFilter: FilterListManager_FilterContentIsLikelyNotAFilter {
    get {
      if case .filterContentIsLikelyNotAFilter(let v)? = error {return v}
      return FilterListManager_FilterContentIsLikelyNotAFilter()
    }
    set {error = .filterContentIsLikelyNotAFilter(newValue)}
  }

  public var filterParserError: FilterListManager_FilterParserError {
    get {
      if case .filterParserError(let v)? = error {return v}
      return FilterListManager_FilterParserError()
    }
    set {error = .filterParserError(newValue)}
  }

  public var fieldIsEmpty: FilterListManager_FieldIsEmpty {
    get {
      if case .fieldIsEmpty(let v)? = error {return v}
      return FilterListManager_FieldIsEmpty()
    }
    set {error = .fieldIsEmpty(newValue)}
  }

  public var mutex: FilterListManager_Mutex {
    get {
      if case .mutex(let v)? = error {return v}
      return FilterListManager_Mutex()
    }
    set {error = .mutex(newValue)}
  }

  public var invalidConfiguration: FilterListManager_InvalidConfiguration {
    get {
      if case .invalidConfiguration(let v)? = error {return v}
      return FilterListManager_InvalidConfiguration()
    }
    set {error = .invalidConfiguration(newValue)}
  }

  public var other: FilterListManager_Other {
    get {
      if case .other(let v)? = error {return v}
      return FilterListManager_Other()
    }
    set {error = .other(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Error: Equatable, Sendable {
    case cannotOpenDatabase(FilterListManager_CannotOpenDatabase)
    case notADatabase(FilterListManager_NotADatabase)
    case databaseBusy(FilterListManager_DatabaseBusy)
    case diskFull(FilterListManager_DiskFull)
    case entityNotFound(FilterListManager_EntityNotFound)
    case pathNotFound(FilterListManager_PathNotFound)
    case pathHasDeniedPermission(FilterListManager_PathHasDeniedPermission)
    case pathAlreadyExists(FilterListManager_PathAlreadyExists)
    case timedOut(FilterListManager_TimedOut)
    case httpClientNetworkError(FilterListManager_HttpClientNetworkError)
    case httpStrict200Response(FilterListManager_HttpStrict200Response)
    case httpClientBodyRecoveryFailed(FilterListManager_HttpClientBodyRecoveryFailed)
    case filterContentIsLikelyNotAFilter(FilterListManager_FilterContentIsLikelyNotAFilter)
    case filterParserError(FilterListManager_FilterParserError)
    case fieldIsEmpty(FilterListManager_FieldIsEmpty)
    case mutex(FilterListManager_Mutex)
    case invalidConfiguration(FilterListManager_InvalidConfiguration)
    case other(FilterListManager_Other)

  }

  public init() {}
}

public struct FilterListManager_CannotOpenDatabase: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct FilterListManager_NotADatabase: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct FilterListManager_DiskFull: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct FilterListManager_DatabaseBusy: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct FilterListManager_EntityNotFound: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var entityID: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct FilterListManager_PathNotFound: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var path: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct FilterListManager_PathHasDeniedPermission: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var path: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct FilterListManager_PathAlreadyExists: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var path: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Do not duplicate the message
public struct FilterListManager_TimedOut: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Do not duplicate the message
public struct FilterListManager_HttpClientNetworkError: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct FilterListManager_HttpStrict200Response: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var statusCode: UInt32 = 0

  public var url: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Do not duplicate the message
public struct FilterListManager_HttpClientBodyRecoveryFailed: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Do not duplicate the message
public struct FilterListManager_FilterContentIsLikelyNotAFilter: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Do not duplicate the message
public struct FilterListManager_FilterParserError: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct FilterListManager_FieldIsEmpty: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var fieldName: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Do not duplicate the message
public struct FilterListManager_Mutex: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Do not duplicate the message
public struct FilterListManager_InvalidConfiguration: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var msg: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Do not duplicate the message
public struct FilterListManager_Other: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "filter_list_manager"

extension FilterListManager_AGOuterError: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AGOuterError"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "message"),
    2: .standard(proto: "cannot_open_database"),
    3: .standard(proto: "not_a_database"),
    4: .standard(proto: "database_busy"),
    5: .standard(proto: "disk_full"),
    6: .standard(proto: "entity_not_found"),
    7: .standard(proto: "path_not_found"),
    8: .standard(proto: "path_has_denied_permission"),
    9: .standard(proto: "path_already_exists"),
    10: .standard(proto: "timed_out"),
    11: .standard(proto: "http_client_network_error"),
    12: .standard(proto: "http_strict_200_response"),
    13: .standard(proto: "http_client_body_recovery_failed"),
    14: .standard(proto: "filter_content_is_likely_not_a_filter"),
    15: .standard(proto: "filter_parser_error"),
    16: .standard(proto: "field_is_empty"),
    17: .same(proto: "mutex"),
    18: .standard(proto: "invalid_configuration"),
    19: .same(proto: "other"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.message) }()
      case 2: try {
        var v: FilterListManager_CannotOpenDatabase?
        var hadOneofValue = false
        if let current = self.error {
          hadOneofValue = true
          if case .cannotOpenDatabase(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.error = .cannotOpenDatabase(v)
        }
      }()
      case 3: try {
        var v: FilterListManager_NotADatabase?
        var hadOneofValue = false
        if let current = self.error {
          hadOneofValue = true
          if case .notADatabase(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.error = .notADatabase(v)
        }
      }()
      case 4: try {
        var v: FilterListManager_DatabaseBusy?
        var hadOneofValue = false
        if let current = self.error {
          hadOneofValue = true
          if case .databaseBusy(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.error = .databaseBusy(v)
        }
      }()
      case 5: try {
        var v: FilterListManager_DiskFull?
        var hadOneofValue = false
        if let current = self.error {
          hadOneofValue = true
          if case .diskFull(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.error = .diskFull(v)
        }
      }()
      case 6: try {
        var v: FilterListManager_EntityNotFound?
        var hadOneofValue = false
        if let current = self.error {
          hadOneofValue = true
          if case .entityNotFound(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.error = .entityNotFound(v)
        }
      }()
      case 7: try {
        var v: FilterListManager_PathNotFound?
        var hadOneofValue = false
        if let current = self.error {
          hadOneofValue = true
          if case .pathNotFound(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.error = .pathNotFound(v)
        }
      }()
      case 8: try {
        var v: FilterListManager_PathHasDeniedPermission?
        var hadOneofValue = false
        if let current = self.error {
          hadOneofValue = true
          if case .pathHasDeniedPermission(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.error = .pathHasDeniedPermission(v)
        }
      }()
      case 9: try {
        var v: FilterListManager_PathAlreadyExists?
        var hadOneofValue = false
        if let current = self.error {
          hadOneofValue = true
          if case .pathAlreadyExists(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.error = .pathAlreadyExists(v)
        }
      }()
      case 10: try {
        var v: FilterListManager_TimedOut?
        var hadOneofValue = false
        if let current = self.error {
          hadOneofValue = true
          if case .timedOut(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.error = .timedOut(v)
        }
      }()
      case 11: try {
        var v: FilterListManager_HttpClientNetworkError?
        var hadOneofValue = false
        if let current = self.error {
          hadOneofValue = true
          if case .httpClientNetworkError(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.error = .httpClientNetworkError(v)
        }
      }()
      case 12: try {
        var v: FilterListManager_HttpStrict200Response?
        var hadOneofValue = false
        if let current = self.error {
          hadOneofValue = true
          if case .httpStrict200Response(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.error = .httpStrict200Response(v)
        }
      }()
      case 13: try {
        var v: FilterListManager_HttpClientBodyRecoveryFailed?
        var hadOneofValue = false
        if let current = self.error {
          hadOneofValue = true
          if case .httpClientBodyRecoveryFailed(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.error = .httpClientBodyRecoveryFailed(v)
        }
      }()
      case 14: try {
        var v: FilterListManager_FilterContentIsLikelyNotAFilter?
        var hadOneofValue = false
        if let current = self.error {
          hadOneofValue = true
          if case .filterContentIsLikelyNotAFilter(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.error = .filterContentIsLikelyNotAFilter(v)
        }
      }()
      case 15: try {
        var v: FilterListManager_FilterParserError?
        var hadOneofValue = false
        if let current = self.error {
          hadOneofValue = true
          if case .filterParserError(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.error = .filterParserError(v)
        }
      }()
      case 16: try {
        var v: FilterListManager_FieldIsEmpty?
        var hadOneofValue = false
        if let current = self.error {
          hadOneofValue = true
          if case .fieldIsEmpty(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.error = .fieldIsEmpty(v)
        }
      }()
      case 17: try {
        var v: FilterListManager_Mutex?
        var hadOneofValue = false
        if let current = self.error {
          hadOneofValue = true
          if case .mutex(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.error = .mutex(v)
        }
      }()
      case 18: try {
        var v: FilterListManager_InvalidConfiguration?
        var hadOneofValue = false
        if let current = self.error {
          hadOneofValue = true
          if case .invalidConfiguration(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.error = .invalidConfiguration(v)
        }
      }()
      case 19: try {
        var v: FilterListManager_Other?
        var hadOneofValue = false
        if let current = self.error {
          hadOneofValue = true
          if case .other(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.error = .other(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 1)
    }
    switch self.error {
    case .cannotOpenDatabase?: try {
      guard case .cannotOpenDatabase(let v)? = self.error else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .notADatabase?: try {
      guard case .notADatabase(let v)? = self.error else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .databaseBusy?: try {
      guard case .databaseBusy(let v)? = self.error else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .diskFull?: try {
      guard case .diskFull(let v)? = self.error else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case .entityNotFound?: try {
      guard case .entityNotFound(let v)? = self.error else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }()
    case .pathNotFound?: try {
      guard case .pathNotFound(let v)? = self.error else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }()
    case .pathHasDeniedPermission?: try {
      guard case .pathHasDeniedPermission(let v)? = self.error else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    }()
    case .pathAlreadyExists?: try {
      guard case .pathAlreadyExists(let v)? = self.error else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
    }()
    case .timedOut?: try {
      guard case .timedOut(let v)? = self.error else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
    }()
    case .httpClientNetworkError?: try {
      guard case .httpClientNetworkError(let v)? = self.error else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
    }()
    case .httpStrict200Response?: try {
      guard case .httpStrict200Response(let v)? = self.error else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
    }()
    case .httpClientBodyRecoveryFailed?: try {
      guard case .httpClientBodyRecoveryFailed(let v)? = self.error else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
    }()
    case .filterContentIsLikelyNotAFilter?: try {
      guard case .filterContentIsLikelyNotAFilter(let v)? = self.error else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 14)
    }()
    case .filterParserError?: try {
      guard case .filterParserError(let v)? = self.error else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
    }()
    case .fieldIsEmpty?: try {
      guard case .fieldIsEmpty(let v)? = self.error else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 16)
    }()
    case .mutex?: try {
      guard case .mutex(let v)? = self.error else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 17)
    }()
    case .invalidConfiguration?: try {
      guard case .invalidConfiguration(let v)? = self.error else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 18)
    }()
    case .other?: try {
      guard case .other(let v)? = self.error else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 19)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: FilterListManager_AGOuterError, rhs: FilterListManager_AGOuterError) -> Bool {
    if lhs.message != rhs.message {return false}
    if lhs.error != rhs.error {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension FilterListManager_CannotOpenDatabase: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CannotOpenDatabase"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: FilterListManager_CannotOpenDatabase, rhs: FilterListManager_CannotOpenDatabase) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension FilterListManager_NotADatabase: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".NotADatabase"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: FilterListManager_NotADatabase, rhs: FilterListManager_NotADatabase) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension FilterListManager_DiskFull: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DiskFull"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: FilterListManager_DiskFull, rhs: FilterListManager_DiskFull) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension FilterListManager_DatabaseBusy: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DatabaseBusy"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: FilterListManager_DatabaseBusy, rhs: FilterListManager_DatabaseBusy) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension FilterListManager_EntityNotFound: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".EntityNotFound"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "entity_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.entityID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.entityID != 0 {
      try visitor.visitSingularInt64Field(value: self.entityID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: FilterListManager_EntityNotFound, rhs: FilterListManager_EntityNotFound) -> Bool {
    if lhs.entityID != rhs.entityID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension FilterListManager_PathNotFound: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PathNotFound"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "path"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.path) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.path.isEmpty {
      try visitor.visitSingularStringField(value: self.path, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: FilterListManager_PathNotFound, rhs: FilterListManager_PathNotFound) -> Bool {
    if lhs.path != rhs.path {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension FilterListManager_PathHasDeniedPermission: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PathHasDeniedPermission"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "path"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.path) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.path.isEmpty {
      try visitor.visitSingularStringField(value: self.path, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: FilterListManager_PathHasDeniedPermission, rhs: FilterListManager_PathHasDeniedPermission) -> Bool {
    if lhs.path != rhs.path {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension FilterListManager_PathAlreadyExists: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PathAlreadyExists"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "path"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.path) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.path.isEmpty {
      try visitor.visitSingularStringField(value: self.path, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: FilterListManager_PathAlreadyExists, rhs: FilterListManager_PathAlreadyExists) -> Bool {
    if lhs.path != rhs.path {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension FilterListManager_TimedOut: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TimedOut"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: FilterListManager_TimedOut, rhs: FilterListManager_TimedOut) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension FilterListManager_HttpClientNetworkError: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".HttpClientNetworkError"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: FilterListManager_HttpClientNetworkError, rhs: FilterListManager_HttpClientNetworkError) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension FilterListManager_HttpStrict200Response: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".HttpStrict200Response"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "status_code"),
    2: .same(proto: "url"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.statusCode) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.url) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.statusCode != 0 {
      try visitor.visitSingularUInt32Field(value: self.statusCode, fieldNumber: 1)
    }
    if !self.url.isEmpty {
      try visitor.visitSingularStringField(value: self.url, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: FilterListManager_HttpStrict200Response, rhs: FilterListManager_HttpStrict200Response) -> Bool {
    if lhs.statusCode != rhs.statusCode {return false}
    if lhs.url != rhs.url {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension FilterListManager_HttpClientBodyRecoveryFailed: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".HttpClientBodyRecoveryFailed"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: FilterListManager_HttpClientBodyRecoveryFailed, rhs: FilterListManager_HttpClientBodyRecoveryFailed) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension FilterListManager_FilterContentIsLikelyNotAFilter: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".FilterContentIsLikelyNotAFilter"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: FilterListManager_FilterContentIsLikelyNotAFilter, rhs: FilterListManager_FilterContentIsLikelyNotAFilter) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension FilterListManager_FilterParserError: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".FilterParserError"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: FilterListManager_FilterParserError, rhs: FilterListManager_FilterParserError) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension FilterListManager_FieldIsEmpty: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".FieldIsEmpty"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "field_name"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.fieldName) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.fieldName.isEmpty {
      try visitor.visitSingularStringField(value: self.fieldName, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: FilterListManager_FieldIsEmpty, rhs: FilterListManager_FieldIsEmpty) -> Bool {
    if lhs.fieldName != rhs.fieldName {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension FilterListManager_Mutex: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Mutex"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: FilterListManager_Mutex, rhs: FilterListManager_Mutex) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension FilterListManager_InvalidConfiguration: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".InvalidConfiguration"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "msg"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.msg) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.msg.isEmpty {
      try visitor.visitSingularStringField(value: self.msg, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: FilterListManager_InvalidConfiguration, rhs: FilterListManager_InvalidConfiguration) -> Bool {
    if lhs.msg != rhs.msg {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension FilterListManager_Other: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Other"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: FilterListManager_Other, rhs: FilterListManager_Other) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
